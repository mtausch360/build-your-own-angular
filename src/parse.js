/*
  will contain


    A Lexer
      -takes the original expression string and returns an array of tokens paresed form that string
        ex. 'a + b' -> ['a', '+', 'b']


    An AST Builder
      -takes the array of tokens generated by the lexer, and builds up an abstract syntax tree. The
        tree represents the syntactic structure of the expression as nexted javascript objects
        ex cont from above.

        {
          type: AST.BinaryExpression,
          operator: '+',
          left: {
            type: AST.Identifier,
            name: 'a'
          },
          right: {
            type: AST.Identifier,
            name: 'b'
          }
        }


    An AST Compiler
      -takes the abstract syntax tree and compiles it into a JavaScript function that evaluates the 
        expression represented in the tree.
        ex


    a Parser
      -responsible for combining the low-level steps ^^^. 

 */


////////////////////////////////////////////////////////////////////
//parse
//
//creates a lexer which is passed into parser, the same lexer is then passed into AST by Parser
//
////////////////////////////////////////////////////////////////////

function parse(expr) {

  //create a lexer to construct a parser
  var lexer = new Lexer();

  var parser = new Parser(lexer);

  return parser.parse(expr);

}


////////////////////////////////////////////////////////////////////
//Parser
//
//parser can only be instantiated with a lexer
////////////////////////////////////////////////////////////////////

function Parser(lexer) {

  //lexer constructed in parse
  this.lexer = lexer;

  //create new ast with lexer
  this.ast = new AST(this.lexer);


  //create astcompiler with ast

  //we have in the ASTCompiler, the lexer that was constructed in parse
  //an AST with the same lexer on it

  this.astCompiler = new ASTCompiler(this.ast);

}

//compile == parse
Parser.prototype.parse = function(text) {
  return this.astCompiler.compile(text);
};


////////////////////////////////////////////////////////////////////
//AST
//
//AST can only be instantiated with a lexer
////////////////////////////////////////////////////////////////////

function AST(lexer) {
  this.lexer = lexer;
}

//marker constants
AST.Program = "Program";
AST.Literal = "Literal";

//AST compilation will be done here
AST.prototype.ast = function(text) {
  //stores lexer tokens in tokens property
  this.tokens = this.lexer.lex(text);

  //builds ast object which is returned
  return this.program();

};


AST.prototype.program = function() {
  return {
    type: AST.Program,
    body: this.constant()
  };
};

//have a feeling that this is only very temporary
AST.prototype.constant = function() {
  return {
    type: AST.Literal,
    value: this.tokens[0].value
  };
};

////////////////////////////////////////////////////////////////////
//ASTCompiler
//
//
////////////////////////////////////////////////////////////////////

//astBuilder is an ast with the lexer created in parse
//
//note: referring to astBuilder as astInstance
function ASTCompiler(astInstance) {

  //astInstance is an AST instance
  this.astInstance = astInstance;

}

//AST compilation will be done here
ASTCompiler.prototype.compile = function(text) {

  //lexing is called here
  var ast = this.astInstance.ast(text);

  console.log(ast);

  //initialize state
  this.state = {
    body: []
  };

  //walk the tree
  this.recurse(ast);


  /* jshint -W054 */

  //functionally similar to eval which jshint doesn't like
  //  -Why?

  return new Function(this.state.body.join(''));
  /* jshint +W054 */

};

ASTCompiler.prototype.recurse = function(ast) {

  switch (ast.type) {

    case AST.Program:
      //generate return statement for the whole expression
      this.state.body.push('return ', this.recurse(ast.body), ';');
      //syntax is equivalent to pushing three elements into the array
      break;

    case AST.Literal:

      //a literal is a leaf node of the AST
      return ast.value;

  }

};


////////////////////////////////////////////////////////////////////
//Lexer
//
//creates tokens, so far handles literals
////////////////////////////////////////////////////////////////////

function Lexer() {

}


//Tokenization will be done here
//returns tokens from text
Lexer.prototype.lex = function(text) {

  this.text = text;

  //index in the string
  this.index = 0;
  //current character
  this.ch = undefined;

  this.tokens = [];

  while (this.index < this.text.length) {

    this.ch = this.text.charAt(this.index);

    if (this.isNumber(this.ch)) {

      this.readNumber();

    } else {

      throw "unexpected next character: " + this.ch;

    }

  }

  return this.tokens;

};


//function to handle comparison if character is a number
Lexer.prototype.isNumber = function(ch) {

  return '0' <= ch && '9' >= ch;

};


//function to handle literal number parsing
Lexer.prototype.readNumber = function() {

  var number = '';

  while (this.index < this.text.length) {

    var ch = this.text.charAt(this.index);

    if (this.isNumber(ch)) {
      number += ch;

    } else {

      break;
    }

    this.index++;
  }

  this.tokens.push({
    text: number,
    value: Number(number)
  });

};
